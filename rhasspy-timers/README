First version of rhasspy assistant "kitchen timers.

Intro

I've had a "google assistant" in my kitchen for a while, and I mostly use
it for setting and managing the timers I use for cooking.  As I recall,
it used to work pretty well, but has become sufficiently unreliable that
I can no longer trust it*.  This is a "prototype" to see if I can replace
the kitchen timer functionality with something that I can trust that
does what I need.  Since this is just a prototype to see if it's plausible, I'll
write the timer module to Rhasspy in "bash", which is always a bad idea, but
will encourage me to switch to a real language (likely GO) before I get too far.

To make this little project a bit more tractable, I'm going to limit the scope more
than the Google assistant does, but that's OK if I can trust it:
- No "free form" input, the set of sentences used to manipulate timers are fixed
- The system will make mistakes, so there needs to be an easy way to "undo" them
- Follow the UI principle of "least astonishment"
- Eliminate the major annoyances of the Google assistant:
  "hey google, turn off the music" ... "OK, I've cancelled all the timers for you"
  "hey google, stop that blasted timer!!"  .. "Sorry, can't hear you, too much timer noise happening"

Features:
- Set or cancel optionally named timers
- add additional time to existing (or recently expired) timers
- Query the state of the timers
- Allow specially named timers to have pre-set settings and behaviors

Strategy

Use a FIFO as an event Queue that will handle messages, either from the Rhasspy event system, or from timers tthat I set expiring.  All "events" are dumped into the Queue, and read and processed sequentially.

Intents from Rhasspy come as JSON messages, that embed key=value pairs
that are defined in the sentence templates.  The easiest way (for me)
to manage this is to massage the JSON into a sequence of the key=value
pairs, and use that as "arguments" to the state machine that is processing
items from the Queue.

Dependencies:
jq - for manipulating the JSON data generated by the Rhasspy intent system
mosquitto_pub, mosquitto_sub - for interfacing to the Rhassperry pub/sub message bus
screen - for managing communication with the various sub-processes

Files:
* run
  Startup script -  Invoked with the crontab entry: "@reboot /home/suhler/assistant/run"
  This starts all the processes with "screen", so I can monitor and debug the various parts easily
  
* say
  Test program for text to speech

* timer-sentences.ini
  Rhasspy fsticuffs sentence templates for the timers

* timers.bash
  timer management, in bash (hee hee)

* sounds
  Directory of canned sounds to play

* nouns.txt
  list of nouns for timer names

* watch_messages
  Utility to print Rhasspy messages
